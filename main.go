package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

type AutoGenerated struct {
	QueryCost       int     `json:"queryCost"`
	Latitude        float64 `json:"latitude"`
	Longitude       float64 `json:"longitude"`
	ResolvedAddress string  `json:"resolvedAddress"`
	Address         string  `json:"address"`
	Timezone        string  `json:"timezone"`
	Tzoffset        float64 `json:"tzoffset"`
	Days            []struct {
		Datetime       string      `json:"datetime"`
		DatetimeEpoch  int         `json:"datetimeEpoch"`
		Tempmax        float64     `json:"tempmax"`
		Tempmin        float64     `json:"tempmin"`
		Temp           float64     `json:"temp"`
		Feelslikemax   float64     `json:"feelslikemax"`
		Feelslikemin   float64     `json:"feelslikemin"`
		Feelslike      float64     `json:"feelslike"`
		Dew            float64     `json:"dew"`
		Humidity       float64     `json:"humidity"`
		Precip         float64     `json:"precip"`
		Precipprob     float64     `json:"precipprob"`
		Precipcover    float64     `json:"precipcover"`
		Preciptype     interface{} `json:"preciptype"`
		Snow           float64     `json:"snow"`
		Snowdepth      float64     `json:"snowdepth"`
		Windgust       float64     `json:"windgust"`
		Windspeed      float64     `json:"windspeed"`
		Winddir        float64     `json:"winddir"`
		Pressure       float64     `json:"pressure"`
		Cloudcover     float64     `json:"cloudcover"`
		Visibility     float64     `json:"visibility"`
		Solarradiation float64     `json:"solarradiation"`
		Solarenergy    float64     `json:"solarenergy"`
		Uvindex        float64     `json:"uvindex"`
		Severerisk     float64     `json:"severerisk"`
		Sunrise        string      `json:"sunrise"`
		SunriseEpoch   int         `json:"sunriseEpoch"`
		Sunset         string      `json:"sunset"`
		SunsetEpoch    int         `json:"sunsetEpoch"`
		Moonphase      float64     `json:"moonphase"`
		Conditions     string      `json:"conditions"`
		Description    string      `json:"description"`
		Icon           string      `json:"icon"`
		Stations       interface{} `json:"stations"`
		Source         string      `json:"source"`
	} `json:"days"`
}

func formHandler(w http.ResponseWriter, r *http.Request) {
	if err := r.ParseForm(); err != nil {
		fmt.Fprintf(w, "ParseForm() err: %v", err)
		return
	}
	city := r.FormValue("city")
	DataS := r.FormValue("dateFrom")
	DataE := r.FormValue("dateTo")
	Firsthlf := "https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/"
	Endhlf := "?unitGroup=metric&elements=datetime%2Cicon&include=days&key=B8WZUP4ZTLXFHBRF3XW29DPDT&contentType=json"
	all := Firsthlf + city + "/" + DataS + "/" + DataE + Endhlf
	//fmt.Fprintf(w, "All = \n%s\n", all)
	// Get request
	resp, err := http.Get(all)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result AutoGenerated
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}

	// fmt.Println(PrettyPrint(result))
	// Loop through the data node for the FirstName
	for _, rec := range result.Days {
		if rec.Icon == "rain" {

			fmt.Fprintf(w, rec.Datetime+": ")
			fmt.Fprintf(w, rec.Icon)
			fmt.Fprintf(w, "\n")

		}

	}
}

func start() {
	resp, err := http.Get("https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/20.322832, 40.050798/2022-08-30/2022-09-12?unitGroup=metric&include=days&key=B8WZUP4ZTLXFHBRF3XW29DPDT&contentType=json")
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte
	fmt.Println(string(body))              // convert to string before print
}

func main() {
	fileServer := http.FileServer(http.Dir("./static"))
	http.Handle("/", fileServer)
	http.HandleFunc("/form.html/form", formHandler)

	fmt.Printf("Strating the server at port 8080 \n")
	if err := http.ListenAndServe(":8080", nil); err != nil {
		log.Fatal(err)
	}
}
